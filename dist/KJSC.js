!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.KJSC=t():e.KJSC=t()}(this,(()=>(()=>{var e={811:()=>{}},t={};function a(o){var r=t[o];if(void 0!==r)return r.exports;var s=t[o]={exports:{}};return e[o](s,s.exports,a),s.exports}a.d=(e,t)=>{for(var o in t)a.o(t,o)&&!a.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},a.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),a.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var o={};return(()=>{"use strict";a.r(o),a.d(o,{ConfigUtil:()=>e,Database:()=>r,Debouncer:()=>s.Debouncer,Shuffler:()=>t});class e{static validateConfiguration(e){if(!e.maximalTemplate&&!e.minimalTemplate)throw new Error("validateConfiguration must be given an input object that has either a maximalTemplate property or a minimalTemplate property. However, the input object had neither.");if(!e.configToValidate)throw new Error("validateConfiguration must be given an input object that has a configToValidate property. However, the input argument had no such property.");for(let t of Object.keys(e.configToValidate))if(!e.maximalTemplate.hasOwnProperty(t))throw new Error(`Passed in config has unrecognized property ${t}`);if(e.minimalTemplate)for(let t of Object.keys(e.minimalTemplate))if(!e.configToValidate.hasOwnProperty(t))throw new Error(`Passed in config is missing required ${t} key`);for(let t of Object.keys(e.maximalTemplate))e.configToValidate.hasOwnProperty(t)||(e.configToValidate[t]=e.maximalTemplate[t]);return e.configToValidate}}class t{static getRandomIndicesListForLength(e){let t=[];for(let a=0;a<e;a++)t.push(a);let a=[];for(;t.length>0;){const e=parseInt(Math.random()*t.length);a.push(t[e]),t.splice(e,1)}return a}}class r{static MAXIMAL_TEMPLATE={databaseName:null,objectStoreName:null};static MINIMAL_TEMPLATE={databaseName:null,objectStoreName:null};#e;#t;#a;constructor(t){let a;e.validateConfiguration({maximalTemplate:r.MAXIMAL_TEMPLATE,minimalTemplate:r.MINIMAL_TEMPLATE,configToValidate:t}),this.#e=t,this.#a=new Promise(((e,t)=>{a=e})),console.log("Making database open request");const o=indexedDB.open(this.#e.databaseName);o.onerror=e=>{console.error(`Problem opening database with name ${this.#e.databaseName}: ${e}`)},o.onsuccess=e=>{this.#t=e.target.result,console.log(`Successfully opened database with name ${this.#e.databaseName}`),a()},o.onupgradeneeded=e=>{this.#t=e.target.result,console.log("onupgradeneeded called. Rebuilding a new database."),this.#t.createObjectStore(this.#e.objectStoreName)}}async waitForDatabaseToLoad(){await this.#a}write(e){if(!e.hasOwnProperty("key"))throw new Error('Database.write called using an argument object that did not have a "key" property.');if(!e.hasOwnProperty("value"))throw new Error('Database.write called using an argument object that did not have a "value" property.');const t=this.#t.transaction([this.#e.objectStoreName],"readwrite").objectStore(this.#e.objectStoreName).put(e.value,e.key);t.onerror=e=>{console.error("Error calling Database.write()"),console.error(e)},t.onsuccess=t=>{console.log(`Successfully wrote value to database with key ${e.key}. Remove this log line soon.`)}}async read(e){return await new Promise(((t,a)=>{const o=this.#t.transaction([this.#e.objectStoreName],"readonly").objectStore(this.#e.objectStoreName).get(e);o.onerror=t=>{console.error(`Failed to read key ${e}`),a(t)},o.onsuccess=e=>{t(e.target.result)}}))}async hasKey(e){return await new Promise(((t,a)=>{const o=this.#t.transaction([this.#e.objectStoreName],"readonly").objectStore(this.#e.objectStoreName).openCursor(e);o.onerror=t=>{console.error(`Failed to check for key ${e}`),a(t)},o.onsuccess=e=>{const a=e.target.result;t(!!a)}}))}async delete(e){return await new Promise(((t,a)=>{const o=this.#t.transaction([this.#e.objectStoreName],"readwrite").objectStore(this.#e.objectStoreName).delete(e);o.onerror=e=>{console.error(`Error calling Database.delete(): ${e}`),a(e)},o.onsuccess=a=>{t(),console.log(`Successfully deleted entry with key ${e}. Remove this log line soon.`)}}))}async test(){console.log("Running database test");const e=new r({databaseName:"turtleDatabase",objectStoreName:"turtleStoreName"});await new Promise(((e,t)=>{setTimeout(e,1e3)})),console.log(`Does the database have key turtleKey? The answer is ${await e.hasKey("turtleKey")}`),e.write({key:"turtleKey",value:"turtleValue"}),await new Promise(((e,t)=>{setTimeout(e,250)})),console.log(`Does the database have key turtleKey? The answer is ${await e.hasKey("turtleKey")}`),console.log("Read this from the database:"),console.log(await e.read("turtleKey")),e.delete("turtleKey"),await new Promise(((e,t)=>{setTimeout(e,250)})),console.log(`Does the database have key turtleKey? The answer is ${await e.hasKey("turtleKey")}`),console.log("Done with the database test")}}var s=a(811)})(),o})()));